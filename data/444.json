{"error": null, "result": {"nr": 444, "upvote_ids": [], "change_log": [{"type": "create", "when": "2015-05-19T01:48:13Z", "uid": "i9umei6gOH2", "data": "i9unvrfp1635n5", "anon": "no"}, {"type": "update", "when": "2015-05-19T01:49:39Z", "uid": "i9umei6gOH2", "data": "i9unxmg2qe312i", "anon": "no"}, {"uid": "hdjoucuyb836fq", "to": "i9unvrfn2ne5n4", "when": "2015-05-19T02:45:22Z", "anon": "no", "data": "i9upx9owkmt5sx", "type": "i_answer"}], "q_edits": [], "i_edits": [], "unique_views": 53, "bookmarked": 3, "config": {}, "history": [{"subject": "关于lab1  bootmain  ELFHDR的一些疑问 以及readseg函数的一个问题", "content": "<p>在bootmain.c里面可以看到</p>\n<p style=\"font-family:&#34;courier&#34;;font-size:10pt\"><span style=\"font-weight:bold;color:#008000\">#define</span><span style=\"color:#808080\"> </span>ELFHDR<span style=\"color:#808080\">          </span><span style=\"font-weight:bold\">((</span><span style=\"font-weight:bold;color:#000080\">struct</span><span style=\"color:#808080\"> </span>elfhdr<span style=\"color:#808080\"> </span><span style=\"font-weight:bold\">*)</span><span style=\"color:#008080\">0x10000</span><span style=\"font-weight:bold\">)</span></p>\n<p style=\"font-family:&#34;courier&#34;;font-size:10pt\">这里用的是结构体指针强转的方式定义了一个<strong>0x10000</strong>的地址作为elf文件在内存中的入口地址</p>\n<p style=\"font-family:&#34;courier&#34;;font-size:10pt\">而观察tools/kernel.ld文件&#xff0c;开头有这么几句话&#xff1a;</p>\n<p style=\"font-family:&#34;courier&#34;;font-size:10pt\">ENTRY(kern_init)<br /><br />SECTIONS {<br />    /* Load the kernel at this address: &#34;.&#34; means the current address */<br />    . = <strong>0x100000</strong>;</p>\n<p style=\"font-family:&#34;courier&#34;;font-size:10pt\">这里的意思不是说默认了kern_init从内存的<strong>0x100000</strong>开始嘛&#xff1f;与bootmain复制的0x10000不一致</p>\n<p style=\"font-family:&#34;courier&#34;;font-size:10pt\">请问我这里理解哪里有问题</p>\n<p style=\"font-family:&#34;courier&#34;;font-size:10pt\">我观察了试验一的答案程序&#xff0c;仍然是复制到<strong>0x10000</strong>这个地址去&#xff0c;如果改成<strong>0x100000</strong>反而会出现死机报错的现象&#xff0c;因为初次接触makefile或许还有我没注意的地方&#xff0c;麻烦高手解答一下为什么复制到<strong>0x10000</strong>地址</p>\n<p style=\"font-family:&#34;courier&#34;;font-size:10pt\"></p>\n<p style=\"font-family:&#34;courier&#34;;font-size:10pt\">此外还有一个问题&#xff1a;</p>\n<p style=\"font-family:&#34;courier&#34;;font-size:10pt\">readseg函数中有这么一句&#xff1a;</p>\n<p style=\"font-family:&#34;courier&#34;;font-size:10pt\"><span style=\"color:#808080\"></span>va<span style=\"color:#808080\"> </span><span style=\"font-weight:bold\">-=</span><span style=\"color:#808080\"> </span>offset<span style=\"color:#808080\"> </span><span style=\"font-weight:bold\">%</span><span style=\"color:#808080\"> </span>SECTSIZE<span style=\"font-weight:bold\">;</span></p>\n<p style=\"font-family:&#34;courier&#34;;font-size:10pt\">这句程序为什么要用减法来对齐sector地址&#xff0c;这样的话如果offset不是整512字节调用的话就会执行减法&#xff0c;除非指定的va能相对配合&#xff0c;且需要的字节不在硬盘sector头部&#xff0c;虽然整段程序实际上保证了没用到这个计算&#xff0c;读取的都是整段的sector&#xff0c;那么这句话很奇怪的写在这里&#xff0c;还占用了引导扇区的宝贵字节&#xff0c;到底是为了什么呢&#xff1f;</p>", "created": "2015-05-19T01:49:39Z", "uid": "i9umei6gOH2", "anon": "no"}, {"subject": "关于lab1  bootmain  ELFHDR的一些疑问 以及readseg函数的一个问题", "content": "<p>在bootmain.c里面可以看到</p>\n<p style=\"font-family:&#34;courier&#34;;font-size:10pt\"><span style=\"font-weight:bold;color:#008000\">#define</span><span style=\"color:#808080\"> </span>ELFHDR<span style=\"color:#808080\">          </span><span style=\"font-weight:bold\">((</span><span style=\"font-weight:bold;color:#000080\">struct</span><span style=\"color:#808080\"> </span>elfhdr<span style=\"color:#808080\"> </span><span style=\"font-weight:bold\">*)</span><span style=\"color:#008080\">0x10000</span><span style=\"font-weight:bold\">)</span></p>\n<p style=\"font-family:&#34;courier&#34;;font-size:10pt\">这里用的是结构体指针强转的方式定义了一个<strong>0x10000</strong>的地址作为elf文件在内存中的入口地址</p>\n<p style=\"font-family:&#34;courier&#34;;font-size:10pt\">而观察tools/kernel.ld文件&#xff0c;开头有这么几句话&#xff1a;</p>\n<p style=\"font-family:&#34;courier&#34;;font-size:10pt\">ENTRY(kern_init)<br /><br />SECTIONS {<br />    /* Load the kernel at this address: &#34;.&#34; means the current address */<br />    . = <strong>0x100000</strong>;</p>\n<p style=\"font-family:&#34;courier&#34;;font-size:10pt\">这里的意思不是说默认了kern_init从内存的<strong>0x10000</strong>开始嘛&#xff1f;与bootmain复制的0x10000不一致</p>\n<p style=\"font-family:&#34;courier&#34;;font-size:10pt\">请问我这里理解哪里有问题</p>\n<p style=\"font-family:&#34;courier&#34;;font-size:10pt\">我观察了试验一的答案程序&#xff0c;仍然是复制到<strong>0x10000</strong>这个地址去&#xff0c;如果改成<strong>0x100000</strong>反而会出现死机报错的现象&#xff0c;因为初次接触makefile或许还有我没注意的地方&#xff0c;麻烦高手解答一下为什么复制到<strong>0x10000</strong>地址</p>\n<p style=\"font-family:&#34;courier&#34;;font-size:10pt\"></p>\n<p style=\"font-family:&#34;courier&#34;;font-size:10pt\">此外还有一个问题&#xff1a;</p>\n<p style=\"font-family:&#34;courier&#34;;font-size:10pt\">readseg函数中有这么一句&#xff1a;</p>\n<p style=\"font-family:&#34;courier&#34;;font-size:10pt\"><span style=\"color:#808080\"></span>va<span style=\"color:#808080\"> </span><span style=\"font-weight:bold\">-=</span><span style=\"color:#808080\"> </span>offset<span style=\"color:#808080\"> </span><span style=\"font-weight:bold\">%</span><span style=\"color:#808080\"> </span>SECTSIZE<span style=\"font-weight:bold\">;</span></p>\n<p style=\"font-family:&#34;courier&#34;;font-size:10pt\">这句程序为什么要用减法来对齐sector地址&#xff0c;这样的话如果offset不是整512字节调用的话就会执行减法&#xff0c;除非指定的va能相对配合&#xff0c;且需要的字节不在硬盘sector头部&#xff0c;虽然整段程序实际上保证了没用到这个计算&#xff0c;读取的都是整段的sector&#xff0c;那么这句话很奇怪的写在这里&#xff0c;还占用了引导扇区的宝贵字节&#xff0c;到底是为了什么呢&#xff1f;</p>", "created": "2015-05-19T01:48:13Z", "uid": "i9umei6gOH2", "anon": "no"}], "data": {"embed_links": []}, "request_instructor_me": false, "folders": ["lab1"], "type": "question", "tag_good": [], "no_answer": 0, "created": "2015-05-19T01:48:13Z", "t": 1433500551691, "id": "i9unvrfn2ne5n4", "status": "active", "tag_good_arr": [], "default_anonymity": "no", "my_favorite": false, "bucket_order": 2, "is_bookmarked": false, "is_tag_good": false, "bucket_name": "Today", "no_answer_followup": 0, "children": [{"folders": [], "bucket_order": 2, "config": {}, "history": [{"subject": "", "content": "<p>1. ELFHDR定义的那一行后面有个注释</p>\n<p></p>\n<pre>#define ELFHDR          ((struct elfhdr *)0x10000)      // scratch space</pre>\n<p>这个地址实际上是bootloader用来缓存文件头的&#xff0c;和kernel的起始地址没有关系。</p>\n<p></p>\n<p>2. 磁盘只能以512字节为单位进行访问&#xff0c;不能进行任意字节的访问。</p>", "created": "2015-05-19T02:45:22Z", "uid": "hdjoucuyb836fq", "anon": "no"}], "data": {"embed_links": []}, "bucket_name": "Today", "is_tag_endorse": false, "children": [], "tag_endorse": [], "tag_endorse_arr": [], "created": "2015-05-19T02:45:22Z", "id": "i9upx9oss595sw", "type": "i_answer"}], "request_instructor": 0, "tags": ["lab1", "student"], "s_edits": [], "num_favorites": 0}, "aid": "iajh7sp7tfq9t"}