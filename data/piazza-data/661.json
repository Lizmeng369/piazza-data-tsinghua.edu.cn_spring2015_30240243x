{"aid": "ili59k46w763ja", "result": {"folders": ["q&amp;a"], "unique_views": 57, "no_answer": 1, "change_log": [{"data": "ilhjdvy0dlp2cd", "anon": "no", "when": "2016-03-07T05:17:48Z", "uid": "i6ub4vwhQXd", "type": "create"}, {"to": "ilhjdvxo6ck2cc", "anon": "full", "when": "2016-03-07T06:52:47Z", "type": "followup"}, {"to": "ilhjdvxo6ck2cc", "anon": "no", "when": "2016-03-07T11:29:16Z", "uid": "i0dlq4m0wjn5eo", "type": "feedback"}, {"to": "ilhjdvxo6ck2cc", "anon": "full", "when": "2016-03-07T11:54:05Z", "type": "feedback"}, {"to": "ilhjdvxo6ck2cc", "anon": "full", "when": "2016-03-07T12:10:30Z", "type": "feedback"}, {"to": "ilhjdvxo6ck2cc", "anon": "no", "when": "2016-03-07T12:21:34Z", "uid": "i6ub4vwhQXd", "type": "feedback"}], "upvote_ids": [], "id": "ilhjdvxo6ck2cc", "bookmarked": 5, "no_answer_followup": 0, "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "updated": "2016-03-07T06:52:47Z", "no_upvotes": 0, "created": "2016-03-07T06:52:47Z", "type": "followup", "d-bucket": "Yesterday", "id": "ilhms13fe667id", "anon": "full", "bucket_name": "Yesterday", "no_answer": 0, "config": {}, "bucket_order": 3, "data": {"embed_links": null}, "children": [{"folders": [], "updated": "2016-03-07T11:29:16Z", "uid": "i0dlq4m0wjn5eo", "created": "2016-03-07T11:29:16Z", "type": "feedback", "d-bucket": "Yesterday", "id": "ilhwnl7jqbl5gx", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": {"embed_links": null}, "children": [], "subject": "<p>会的啊&#xff0c;用线段树实现的话&#xff0c;如果128K的空闲在左子树&#xff0c;64K的空闲在右子树&#xff0c;那么根据一般的遍历逻辑&#xff0c;就会把左边的128K分割成两个64K&#xff0c;并将其中一个分配出去。</p>"}, {"folders": [], "updated": "2016-03-07T11:54:05Z", "created": "2016-03-07T11:54:05Z", "type": "feedback", "d-bucket": "Yesterday", "id": "ilhxjirgay6zn", "anon": "full", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": {"embed_links": null}, "children": [], "subject": "<p>为什么要用线段树呢, 用链表不就行了吗? 而且时间常数更小?</p>"}, {"folders": [], "updated": "2016-03-07T12:10:30Z", "created": "2016-03-07T12:10:30Z", "config": {}, "children": [], "anon": "full", "bucket_name": "Today", "type": "feedback", "bucket_order": 2, "data": {"embed_links": null}, "id": "ilhy4m5qgte6i0", "subject": "<p>抱歉, 上一句说的不太对, 看了老师给的这个链接<a href=\"http://coolshell.cn/articles/10427.html,\">http://coolshell.cn/articles/10427.html,</a> 貌似的确是要分割128K的块</p>"}, {"folders": [], "updated": "2016-03-07T12:21:34Z", "uid": "i6ub4vwhQXd", "created": "2016-03-07T12:21:34Z", "type": "feedback", "id": "ilhyiuvvmwk6ce", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": {"embed_links": null}, "children": [], "subject": "<p>感觉还是比较模糊&#xff0c;这个链接里面的图示样例是分割64k那块的&#xff0c;但是代码是分割了128K那块&#xff0c;单纯用链表可以做到logN么&#xff1f;</p>"}], "subject": "<p>根据我对buddy system的理解, 如果需要分配64K的内存块, 应该会先从不小于64K的内存块链表上查找有没有空闲块吧? </p>\n<p>而不会出现&#34;有一个128K的空闲块在一个64K的空闲块前&#34;吧?</p>"}], "request_instructor_me": false, "nr": 661, "bucket_order": 2, "config": {}, "status": "active", "tags": ["q&amp;a", "student", "unanswered"], "num_favorites": 0, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2016-03-07T05:17:48Z", "is_tag_good": false, "type": "question", "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1457364618005, "tag_good": [], "tag_good_arr": [], "history": [{"content": "<p>在用Buddy System进行内存分配时&#xff0c;如果有一个128K的空闲块在一个64K的空闲块前&#xff0c;此时需要分配一个64K的内存&#xff0c;那么会分割128K那个空闲块&#xff0c;还是直接使用后面那个64K的空闲块&#xff1f;如果需要满足最优的方案(直接用64K的那块)的话&#xff0c;貌似LogN的时间内出不来结果&#xff1f;</p>", "anon": "no", "subject": "Buddy System需要找到满足条件的最小空闲内存么&#xff1f;", "uid": "i6ub4vwhQXd", "created": "2016-03-07T05:17:48Z"}]}, "error": null}