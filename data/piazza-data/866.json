{"aid": "io8qodycy8a4f0", "result": {"folders": ["lecture19"], "unique_views": 15, "no_answer": 0, "change_log": [{"data": "io8kp1ryt4y5va", "anon": "no", "when": "2016-05-15T12:43:40Z", "uid": "i0iaabhcht167g", "type": "create"}, {"uid": "i0c90j8pjf56sn", "data": "io8opqvh4vf6rc", "when": "2016-05-15T14:36:11Z", "to": "io8kp1rw93n5v9", "anon": "no", "type": "s_answer"}, {"data": "io8oqad4jkh3uv", "anon": "no", "when": "2016-05-15T14:36:36Z", "uid": "i0c90j8pjf56sn", "type": "s_answer_update"}], "upvote_ids": [], "id": "io8kp1rw93n5v9", "bookmarked": 4, "no_answer_followup": 0, "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "is_tag_endorse": false, "created": "2016-05-15T14:36:11Z", "config": {}, "tag_endorse_arr": [], "children": [], "bucket_name": "Today", "type": "s_answer", "tag_endorse": [], "bucket_order": 2, "data": {"embed_links": []}, "id": "io8opqvdtwa6rb", "history": [{"content": "<p>如果在func_b的wait和signal之间加上</p>\n<pre>if(mtp-&gt;next_count&gt;0)\n         up(&amp;(mtp-&gt;next));\n      else\n         up(&amp;(mtp-&gt;mutex));</pre>\n<p>就不会有这个问题。</p>\n<p></p>\n<p>所以我的理解是&#xff0c;尽管一个进程&#xff08;A&#xff09;signal释放了另一个进程&#xff08;B&#xff09;的资源后&#xff0c;B进程应当在用完后把控制权还给A&#xff08;next_count--&#xff09;&#xff0c;而不是继续使用。</p>\n<p>&#xff08;即使用权的交接以临界区为单位&#xff0c;而不是以进程为单位。&#xff09;</p>\n<p></p>\n<p>这就是之前陈渝老师说的</p>\n<p></p>\n<blockquote>\n<p>这样在他退出时&#xff0c;由于next_count&gt;0&#xff0c;所以会执行signal(mt.next)&#xff0c;</p>\n</blockquote>\n<p></p>\n<p></p>", "anon": "no", "subject": "", "uid": "i0c90j8pjf56sn", "created": "2016-05-15T14:36:36Z"}, {"content": "<p>我的理解是&#xff0c;如果在func_b的wait和signal之间加上</p>\n<pre>if(mtp-&gt;next_count&gt;0)\n         up(&amp;(mtp-&gt;next));\n      else\n         up(&amp;(mtp-&gt;mutex));</pre>\n<p>就不会有这个问题。</p>\n<p></p>\n<p>所以我的理解是尽管一个进程&#xff08;A&#xff09;signal释放了另一个进程&#xff08;B&#xff09;的资源后&#xff0c;B进程应当在用完后把控制权还给A&#xff08;next_count--&#xff09;&#xff0c;而不是继续使用。</p>\n<p>&#xff08;即使用权的交接以临界区为单位&#xff0c;而不是以进程为单位。&#xff09;</p>\n<p></p>\n<p>这就是之前陈渝老师说的</p>\n<p></p>\n<blockquote>\n<p>这样在他退出时&#xff0c;由于next_count&gt;0&#xff0c;所以会执行signal(mt.next)&#xff0c;</p>\n</blockquote>\n<p></p>\n<p></p>", "anon": "no", "subject": "", "uid": "i0c90j8pjf56sn", "created": "2016-05-15T14:36:11Z"}]}], "request_instructor_me": false, "nr": 866, "bucket_order": 2, "config": {}, "status": "active", "tags": ["lecture19", "student"], "num_favorites": 0, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2016-05-15T12:43:40Z", "is_tag_good": false, "type": "question", "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1463326267044, "tag_good": [], "tag_good_arr": [], "history": [{"content": "<p>在完成lab7的时候突然考虑到ucore实现中一种情况可能会导致管程next_count大于1&#xff0c;但课上课下老师和同学说next_count不会大于1&#xff08;我之前也一直认为不会大于1&#xff09;</p>\n<p>构造这种情况需要使用3个线程a,b,c、2个条件c1,c2&#xff0c;对应函数大概如下</p>\n<ul><li>func_a(): wait(c1)</li><li>func_b(): wait(c2) signal(c1)</li><li>func_c(): signal(c2&#xff09;</li></ul>\n<p></p>\n<p>假设abc依次执行。</p>\n<ol><li>线程a遇到条件c1阻塞&#xff0c;于是在wait中关闭互斥锁。</li><li>线程b进入&#xff0c;遇到条件c2阻塞&#xff0c;并在wait中关闭互斥锁。</li><li>线程c进入&#xff0c;在signal函数中up条件c2的信号量&#xff0c;并down信号量next阻塞&#xff08;Hoare机制&#xff09;&#xff0c;next_count为1</li><li>线程b继续执行&#xff0c;在signal函数中由于c1被线程a需求&#xff0c;于是线程b会up条件c1的信号量&#xff0c;并down信号量next阻塞&#xff0c;此时&#xff0c;next被down了两次&#xff0c;对应next_count为2</li><li>线程a结束&#xff0c;结束时唤醒线程b&#xff0c;唤醒后next_count减为1</li><li>线程b结束&#xff0c;结束时唤醒线程c&#xff0c;唤醒后next_count为0</li><li>线程c结束&#xff0c;关闭互斥锁</li></ol>\n<p></p>", "anon": "no", "subject": "关于ucore管程实现中next_count的想法", "uid": "i0iaabhcht167g", "created": "2016-05-15T12:43:40Z"}]}, "error": null}