{"aid": "j0zezxhzjuu60e", "result": {"status": "active", "unique_views": 41, "request_instructor_me": false, "change_log": [{"type": "create", "anon": "no", "when": "2017-03-30T08:57:10Z", "data": "j0w62if2yxn53z", "uid": "ie7xy53vpn41q7"}, {"type": "update", "anon": "no", "when": "2017-03-30T09:07:58Z", "data": "j0w6gel08qn6hu", "uid": "hdjonbiyfs62ie"}, {"uid": "hdjonbiyfs62ie", "type": "i_answer", "when": "2017-03-30T09:16:44Z", "to": "j0w62iezjlb53y", "anon": "no", "data": "j0w6rogllql1m8"}, {"to": "j0w62iezjlb53y", "anon": "no", "when": "2017-04-01T02:06:52Z", "type": "followup", "uid": "ie7xxyhe7dp1jr"}, {"to": "j0w62iezjlb53y", "anon": "no", "when": "2017-04-01T02:13:49Z", "type": "feedback", "uid": "ie7xxyhe7dp1jr"}, {"type": "i_answer_update", "anon": "no", "when": "2017-04-01T13:21:55Z", "data": "j0zaep5qe0f3qg", "uid": "hcrrjuyequh4bt"}], "upvote_ids": [], "id": "j0w62iezjlb53y", "bookmarked": 7, "no_answer": 0, "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "is_tag_endorse": false, "created": "2017-03-30T09:16:44Z", "type": "i_answer", "tag_endorse_arr": [], "id": "j0w6roghbhh1m7", "bucket_name": "Today", "config": {}, "tag_endorse": [], "bucket_order": 2, "data": {"embed_links": []}, "children": [], "history": [{"content": "<p>这个问题涉及kill命令的处理流程。kill命令会导致操作系统给指定进程发一个信号signal&#xff0c;这个信号的响应会触发进程执行相应的信号处理函数&#xff0c;杀掉进程就是在这个函数中进行的。这是一个用户态的函数。详细信息可参考“信号”相关的章节。</p>\n<p></p>\n<p>如果还有疑问&#xff0c;请继续提出。如果明白&#xff0c;建议你对照Linux的实现&#xff0c;在本贴后面详细回复kill命令的处理流程。</p>\n<p></p>\n<p>[陈渝老师] 根据<a href=\"/class/i5j09fnsl7k5x0?cid=1026\">Kaixiang Lei</a>的下述回答&#xff0c;应该存在“不客气的” SIGKILL的处理方式&#xff0c;即用户进程没有得到通知和处理的机会就被kill了。</p>", "anon": "no", "created": "2017-04-01T13:21:55Z", "uid": "hcrrjuyequh4bt", "subject": ""}, {"content": "<p>这个问题涉及kill命令的处理流程。kill命令会导致操作系统给指定进程发一个信号signal&#xff0c;这个信号的响应会触发进程执行相应的信号处理函数&#xff0c;杀掉进程就是在这个函数中进行的。这是一个用户态的函数。详细信息可参考“信号”相关的章节。</p>\n<p></p>\n<p>如果还有疑问&#xff0c;请继续提出。如果明白&#xff0c;建议你对照Linux的实现&#xff0c;在本贴后面详细回复kill命令的处理流程。</p>", "anon": "no", "created": "2017-03-30T09:16:44Z", "uid": "hdjonbiyfs62ie", "subject": ""}]}, {"folders": [], "updated": "2017-04-01T02:06:52Z", "d-bucket": "Yesterday", "no_upvotes": 0, "uid": "ie7xxyhe7dp1jr", "created": "2017-04-01T02:06:52Z", "type": "followup", "no_answer": 0, "id": "j0ymakrrif864n", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [{"folders": [], "updated": "2017-04-01T02:13:49Z", "uid": "ie7xxyhe7dp1jr", "created": "2017-04-01T02:13:49Z", "type": "feedback", "d-bucket": "Yesterday", "id": "j0ymjiii1n135a", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>考虑用 SIGTERM 干掉父进程</p>\n<p></p>\n<pre>#include &lt;stdio.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;unistd.h&gt;\n\nint main()\n{\n\tint fpid = getpid();\n\n\tif(fork() == 0)\n\t{\n\t\tsleep(2);\n\t\tkill(fpid, SIGTERM);\n\t}\n\telse\n\t{\n\t\tfor(;;)\n\t\t\tsleep(10);\n\t}\n}</pre>\n<p></p>\n<p>用 strace 跟踪之</p>\n<p></p>\n<pre>linux&gt; strace ./test\n// ...\ngetpid()                                = 3589\nclone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f8d69233a10) = 3590\nrt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0\nrt_sigaction(SIGCHLD, NULL, {SIG_DFL, [], 0}, 8) = 0\nrt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0\nnanosleep({10, 0}, {8, 140362})         = ? ERESTART_RESTARTBLOCK (Interrupted by signal)\n--- SIGTERM {si_signo=SIGTERM, si_code=SI_USER, si_pid=3590, si_uid=1000} ---\n&#43;&#43;&#43; killed by SIGTERM &#43;&#43;&#43;</pre>\n<p>通过 strace 的输出&#xff0c;我们猜测&#xff0c;父进程等待 sleep 的过程中&#xff0c;因为 SIGTERM signal 而提前返回了&#xff08;用户态&#xff09;。</p>\n<p>之后有可能因为其受到了 SIGTERM signal&#xff0c;而执行了默认的 SIGTERM handler&#xff0c;做了些收尾工作后就结束了。</p>"}], "subject": "<p>Linux 中干掉其他进程的 signal 也有三六九等&#xff0c;有温和的 SIGINT, SIGTERM&#xff0c;也有“不客气的” SIGKILL。</p>\n<p></p>\n<p>考虑以下程序</p>\n<p></p>\n<pre>#include &lt;stdio.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;unistd.h&gt;\n\nint main()\n{\n\tint fpid = getpid();\n\n\tif(fork() == 0)\n\t{\n\t\tsleep(2);\n\t\tkill(fpid, SIGKILL);\n\t}\n\telse\n\t{\n\t\tfor(;;)\n\t\t\tsleep(10);\n\t}\n}</pre>\n<p></p>\n<p>用 sstrace 跟踪之</p>\n<pre>linux&gt; strace ./test\n// ...\ngetpid()                                = 3389\nclone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f967b867a10) = 3390\nrt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0\nrt_sigaction(SIGCHLD, NULL, {SIG_DFL, [], 0}, 8) = 0\nrt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0\nnanosleep({10, 0},  &lt;unfinished ...&gt;\n&#43;&#43;&#43; killed by SIGKILL &#43;&#43;&#43;\nfish: Job 1, “strace ./test” terminated by signal SIGKILL (Forced quit)</pre>\n<p></p>\n<p>通过 strace 的输出&#xff0c;我们猜测&#xff0c;父进程应该是在等待 sleep&#xff0c;但还没等到被唤醒之时&#xff08;有可能还没回到用户态&#xff09;&#xff0c;就被干掉了。</p>"}], "nr": 1026, "bucket_order": 2, "type": "question", "folders": ["lecture11", "2017"], "no_answer_followup": 0, "num_favorites": 0, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "tags": ["2017", "lecture11", "student"], "created": "2017-03-30T08:57:10Z", "is_tag_good": false, "config": {}, "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1491060624983, "tag_good": [{"name": "Yong XIANG", "admin": true, "photo": null, "us": false, "id": "hdjonbiyfs62ie", "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0"], "role": "instructor", "facebook_id": null, "email": "xyong@tsinghua.edu.cn", "admin_permission": 10}], "tag_good_arr": ["hdjonbiyfs62ie"], "history": [{"content": "<p>MOOC中11.4节所讲的“三状态进程模型”&#xff0c;进程在退出前<strong>必须</strong>要到<strong>运行</strong>状态。</p>\n<p></p>\n<p>但是我们又知道&#xff0c;操作系统会提供进程管理器从外部kill一个进程。</p>\n<p></p>\n<p>那么&#xff0c;通过这种方式kill掉的程序如果当时并没有处于运行态&#xff0c;而是在<strong>就绪或等待</strong>状态&#xff0c;那么操作系统会强行使程序进入运行态吗&#xff1f;</p>", "anon": "no", "created": "2017-03-30T09:07:58Z", "uid": "hdjonbiyfs62ie", "subject": "关于上课所讲“三状态进程模型”的疑问"}, {"content": "<p>MOOC中11.4节所讲的“三状态进程模型”&#xff0c;进程在退出前<strong>必须</strong>要到<strong>运行</strong>状态。</p>\n<p></p>\n<p>但是我们又知道&#xff0c;操作系统会提供进程管理器从外部kill一个进程。</p>\n<p></p>\n<p>那么&#xff0c;通过这种方式kill掉的程序如果当时并没有处于运行态&#xff0c;而是在<strong>就绪或等待</strong>状态&#xff0c;那么操作系统会强行使程序进入运行态吗&#xff1f;</p>", "anon": "no", "created": "2017-03-30T08:57:10Z", "uid": "ie7xy53vpn41q7", "subject": "关于上课所讲“三状态进程模型”的疑问"}]}, "error": null}