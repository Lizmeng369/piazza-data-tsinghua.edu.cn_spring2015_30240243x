{"error": null, "result": {"nr": 306, "upvote_ids": [], "change_log": [{"type": "create", "when": "2015-04-15T11:05:25Z", "uid": "i70finilY0O", "data": "i8imtd1kjiq27j", "anon": "no"}, {"uid": "hs2swpdtr91gu", "to": "i8imtd1farc27i", "when": "2015-04-16T03:39:20Z", "anon": "no", "data": "i8jmbjt1o6v2k3", "type": "i_answer"}, {"uid": "i6rgfjo5j1r6c", "to": "i8imtd1farc27i", "when": "2015-04-16T15:54:46Z", "anon": "no", "data": "i8kclbzf3h62xj", "type": "s_answer"}, {"type": "s_answer_update", "when": "2015-04-16T15:55:52Z", "uid": "i6rgfjo5j1r6c", "data": "i8kcmr05wr42jm", "anon": "no"}], "q_edits": [], "i_edits": [], "unique_views": 58, "bookmarked": 5, "config": {}, "history": [{"subject": "关于lab1的特权切换问题", "content": "<p>陈老师在学堂在线视频中讲lab1的challenge实质是在内核栈中模拟出内核到用户的切换和用户到内核的切换。我的问题是lab1_switch_to_user执行后把esp-8,内核栈中的tf_es,tf_ds,tf_ss都付值为USER_DS,但是tf_esp应该怎么付值,参考答案中的switchk2u.tf_esp = (uint32_t)tf &#43; sizeof(struct trapframe) - 8;不理解。还有*((uint32_t *)tf - 1) = (uint32_t)&amp;switchk2u;这句也不理解</p>", "created": "2015-04-15T11:05:25Z", "uid": "i70finilY0O", "anon": "no"}], "data": {"embed_links": []}, "request_instructor_me": false, "folders": ["lab1"], "type": "question", "tag_good": [], "no_answer": 0, "created": "2015-04-15T11:05:25Z", "t": 1433500324854, "id": "i8imtd1farc27i", "status": "active", "tag_good_arr": [], "default_anonymity": "no", "my_favorite": false, "bucket_order": 2, "is_bookmarked": false, "is_tag_good": false, "bucket_name": "Today", "no_answer_followup": 0, "children": [{"folders": [], "bucket_order": 2, "config": {}, "history": [{"subject": "", "content": "<p>tf_esp在struct trapframe中的偏移正好是sizeof(struct trapframe) - 8。</p>\n<p>*((uint32_t *)tf - 1) = (uint32_t)&amp;switchk2u这一句完成了trapframe的赋值&#xff0c;(uint32_t *)tf是一个指针&#xff0c;即将tf指向的那个trapframe的前一个trapframe赋值为switchk2u</p>", "created": "2015-04-16T03:39:20Z", "uid": "hs2swpdtr91gu", "anon": "no"}], "data": {"embed_links": []}, "bucket_name": "Today", "is_tag_endorse": false, "children": [], "tag_endorse": [], "tag_endorse_arr": [], "created": "2015-04-16T03:39:20Z", "id": "i8jmbjsxf912k2", "type": "i_answer"}, {"folders": [], "bucket_order": 2, "config": {}, "history": [{"subject": "", "content": "<p>在trapentry.s中有处理中断的总入口。它在栈中模拟了一个trapframe结构&#xff0c;并用push %esp来实现了一个指针&#xff0c;作为参数调用trapdispatch。返回之后再把所有的参数弹出回复原状。所以我们只需要修改trapframe结构中的cs和esp等的变量即可实现切换特权级。</p>\n<p></p>\n<p>但是&#xff0c;这个切换并不是对称的。从内核态切换到用户态&#xff0c;比从用户态切换到内核态&#xff0c;栈中少了cs和esp两个元素。这个是因为在内核态的时候调用中断并没有发生特权级转换&#xff0c;而在用户态的时候调用中断则出现了特权级转换&#xff08;中断是在内核处理的&#xff09;。这样的话导致了内核态的trapframe不是完整的&#xff0c;它少了cs和esp。所以我们不能直接修改参数中的trapframe&#xff0c;它只是一个被虚拟出来的结构。</p>\n<p></p>\n<p>从内核态切换到用户态的时候&#xff0c;参数的trapframe不是完整的&#xff0c;而我们返回的时候需要返回一个完整的包含cs和esp的trapframe&#xff0c;从而让iret觉得这是一个特权级切换&#xff0c;然后正常进入到用户态。由于参数少了cs和esp&#xff0c;我们切换到用户态的时候&#xff0c;新建一个trapframe实例&#xff0c;它的esp要设置成离trapframe指针相差sizeof(trapframe)-8的位置&#xff0c;才能在返回的时候回到正常的位置。</p>\n<p></p>\n<p>同理从用户态切换到内核态的时候&#xff0c;参数是一个完整的trapframe&#xff0c;但是我们需要返回一个不完整trapframe的指针。所以切换到内核态的时候&#xff0c;需要一个trapframe&#xff0c;它的指针头距离压栈前的栈顶为sizeof(trapframe)-8。</p>\n<p></p>\n<p>所以为了实现的方便&#xff0c;这两种情况分别用了一个实例和一个指针&#xff0c;这个指针设置好之后再把数据搬过去。</p>\n<p></p>\n<p>值得注意的是&#xff0c;最后一句话的效果非常的神奇。由于在调用trapdispatch之前有一句push %esp&#xff0c;所以输入参数作为地址减去8字节之后&#xff0c;就是自己所在的地址。然后让这个地址中的数改为我们想要返回的trapframe的指针&#xff0c;在返回之后经过汇编代码的pop %esp即可把esp移过去trapframe中&#xff0c;让它pop的时候把我们修改过的寄存器的值放进寄存器中&#xff0c;之后再经过一次iret把%esp复原&#xff0c;即可不被察觉地切换特权级。</p>", "created": "2015-04-16T15:55:52Z", "uid": "i6rgfjo5j1r6c", "anon": "no"}, {"subject": "", "content": "<p>在trapentry.s中有处理中断的总入口。它在栈中模拟了一个trapframe结构&#xff0c;并用push %esp来实现了一个指针&#xff0c;作为参数调用trapdispatch。<br />返回之后再把所有的参数弹出回复原状。所以我们只需要修改trapframe结构中的cs和esp等的变量即可实现切换特权级。</p>\n<p>但是&#xff0c;这个切换并不是对称的。从内核态切换到用户态&#xff0c;比从用户态切换到内核态&#xff0c;栈中少了cs和esp两个元素。<br />这个是因为在内核态的时候调用中断并没有发生特权级转换&#xff0c;而在用户态的时候调用中断则出现了特权级转换&#xff08;中断是在内核处理的&#xff09;。<br />这样的话导致了内核态的trapframe不是完整的&#xff0c;它少了cs和esp。所以我们不能直接修改参数中的trapframe&#xff0c;它只是一个被虚拟出来的结构。</p>\n<p>从内核态切换到用户态的时候&#xff0c;参数的trapframe不是完整的&#xff0c;而我们返回的时候需要返回一个完整的包含cs和esp的trapframe&#xff0c;从而让iret觉得<br />这是一个特权级切换&#xff0c;然后正常进入到用户态。由于参数少了cs和esp&#xff0c;我们切换到用户态的时候&#xff0c;新建一个trapframe实例&#xff0c;<br />它的esp要设置成离trapframe指针相差sizeof(trapframe)-8的位置&#xff0c;才能在返回的时候回到正常的位置。</p>\n<p>同理从用户态切换到内核态的时候&#xff0c;参数是一个完整的trapframe&#xff0c;但是我们需要返回一个不完整trapframe的指针。<br />所以切换到内核态的时候&#xff0c;需要一个trapframe&#xff0c;它的指针头距离压栈前的栈顶为sizeof(trapframe)-8。</p>\n<p>所以为了实现的方便&#xff0c;这两种情况分别用了一个实例和一个指针&#xff0c;这个指针设置好之后再把数据搬过去。</p>\n<p>值得注意的是&#xff0c;最后一句话的效果非常的神奇。由于在调用trapdispatch之前有一句push %esp&#xff0c;所以输入参数作为地址减去8字节之后&#xff0c;就是自己所在的地址。<br />然后让这个地址中的数改为我们想要返回的trapframe的指针&#xff0c;在返回之后经过汇编代码的pop %esp即可把esp移过去trapframe中&#xff0c;<br />让它pop的时候把我们修改过的寄存器的值放进寄存器中&#xff0c;之后再经过一次iret把%esp复原&#xff0c;即可不被察觉地切换特权级。</p>", "created": "2015-04-16T15:54:46Z", "uid": "i6rgfjo5j1r6c", "anon": "no"}], "data": {"embed_links": []}, "bucket_name": "Today", "is_tag_endorse": false, "children": [], "tag_endorse": [], "tag_endorse_arr": [], "created": "2015-04-16T15:54:46Z", "id": "i8kclbzef8e2xi", "type": "s_answer"}], "request_instructor": 0, "tags": ["lab1", "student"], "s_edits": [], "num_favorites": 2}, "aid": "iajh2xo6gma4q5"}