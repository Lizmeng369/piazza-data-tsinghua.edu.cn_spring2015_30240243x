{"aid": "imhvaobv3z1jc", "result": {"folders": ["lecture11", "课堂问答"], "unique_views": 69, "no_answer": 0, "change_log": [{"data": "imbbow8iqqe115", "anon": "no", "when": "2016-03-28T01:35:30Z", "uid": "i1jd60b7orl10p", "type": "create"}, {"uid": "i0f9pvv0uxm6ko", "data": "imbhqdacj0253k", "when": "2016-03-28T04:24:36Z", "to": "imbbow8e4w3114", "anon": "no", "type": "s_answer"}, {"data": "imbjbcp4xa6682", "anon": "no", "when": "2016-03-28T05:08:55Z", "uid": "i0f9pvv0uxm6ko", "type": "s_answer_update"}, {"data": "imbn9ny5s2n553", "anon": "no", "when": "2016-03-28T06:59:35Z", "uid": "i0gl5kctugw3xi", "type": "update"}, {"to": "imbbow8e4w3114", "anon": "no", "when": "2016-04-01T13:21:55Z", "uid": "ikx8y1dzPrM", "type": "followup"}], "upvote_ids": [], "id": "imbbow8e4w3114", "bookmarked": 6, "no_answer_followup": 1, "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "is_tag_endorse": false, "created": "2016-03-28T04:24:36Z", "config": {}, "tag_endorse_arr": ["i1jd60b7orl10p"], "children": [], "bucket_name": "Today", "type": "s_answer", "tag_endorse": [{"name": "李云龙", "admin": false, "photo": null, "us": false, "email": "liunyong@gmail.com", "class_sections": ["清华学生_i5j09fnsl7k5x0"], "role": "student", "facebook_id": null, "id": "i1jd60b7orl10p"}], "bucket_order": 2, "data": {"embed_links": []}, "id": "imbhqdaa1xi53i", "history": [{"content": "<p>先从调用switch_to处说起吧&#xff0c;</p>\n<pre>switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));</pre>\n<p>代码是这样的&#xff0c;prev是上一个进程的上下文&#xff0c;next是本进程的上下文。</p>\n<p></p>\n<p>由于这个函数是汇编写的&#xff0c;这里就涉及到x86下C语言对栈帧的使用&#xff0c;这里只介绍相关的少许知识&#xff0c;以下是C调用完switch_to以后的栈帧情况&#xff1a;</p>\n<p></p>\n<p>           --高地址</p>\n<p>----------------------------</p>\n<p>|  arg1: next-&gt;context    |</p>\n<p>----------------------------</p>\n<p>|  arg0: prev-&gt;context    |</p>\n<p>----------------------------</p>\n<p>|  return address            |    ---&gt; esp</p>\n<p>----------------------------</p>\n<p></p>\n<p>现在我们来看位于switch.S中的代码&#xff0c;第一部分是保存现场</p>\n<pre>    movl 4(%esp), %eax          # esp&#43;4的位置即为prev-&gt;context&#xff0c;这句话把这个指针放入了eax中\n    popl 0(%eax)                # 由于esp所在的位置是返回地址&#xff0c;其实在进程切换的角度来看&#xff0c;这个地址就是原进程恢复后该执行的地址&#xff0c;所以把它保存到prev-&gt;context中eip对应的位置。\n    movl %esp, 4(%eax)\t\t# 保存esp&#xff0c;之后的类似&#xff0c;这里的保存顺序很重要&#xff0c;必须按照context的结构来&#xff0c;具体见附录的context结构体描述&#xff0c;这里默认这个顺序是合理的就行了\n    movl %ebx, 8(%eax)\t\t# 保存ebx&#xff0c;以下略\n    movl %ecx, 12(%eax)\n    movl %edx, 16(%eax)\n    movl %esi, 20(%eax)\n    movl %edi, 24(%eax)\n    movl %ebp, 28(%eax)</pre>\n<p></p>\n<p>现在&#xff0c;由于popl了返回地址&#xff0c;栈帧是这样的&#xff1a;</p>\n<p></p>\n<p>        ----高地址</p>\n<p>----------------------------</p>\n<p>|  arg1: next-&gt;context    |</p>\n<p>----------------------------</p>\n<p>|  arg0: prev-&gt;context    |   ---&gt; esp</p>\n<p>----------------------------</p>\n<p></p>\n<p>所以恢复现场是这样的&#xff0c;依旧注意一下恢复顺序&#xff1a;</p>\n<pre>    movl 4(%esp), %eax          # 现在的esp&#43;4对应于next-&gt;context&#xff0c;把这个指针放入eax中\n    # 按context结构来恢复现场                         \t   \n    movl 28(%eax), %ebp\t\t\n    movl 24(%eax), %edi\n    movl 20(%eax), %esi\n    movl 16(%eax), %edx\n    movl 12(%eax), %ecx\n    movl 8(%eax), %ebx\n    movl 4(%eax), %esp</pre>\n<p></p>\n<p>这样以来现场保存和恢复工作就做好了&#xff0c;最后剩跳转到新的进程&#xff1a;</p>\n<pre>    pushl 0(%eax)               # 把next-&gt;context中的eip压入栈\n    ret</pre>\n<p></p>\n<p>注意到我们先弹出了一个原进程的返回地址&#xff0c;现在又压入了一个新进程的返回地址&#xff0c;switch_to没有破坏栈帧结构。</p>\n<p></p>\n<p></p>\n<p>附&#xff1a;</p>\n<p>context类型和在内存中的存放</p>\n<pre>struct context {\n    uint32_t eip;\n    uint32_t esp;\n    uint32_t ebx;\n    uint32_t ecx;\n    uint32_t edx;\n    uint32_t esi;\n    uint32_t edi;\n    uint32_t ebp;\n};</pre>\n<p>在内存中的存放&#xff1a;</p>\n<p>-----------------</p>\n<p>|  context.ebp |     高地址</p>\n<p>-----------------</p>\n<p>|  context.edi   | </p>\n<p>-----------------</p>\n<p>|  context.esi   | </p>\n<p>-----------------</p>\n<p>|  context.eip   | </p>\n<p>-----------------</p>\n<p>|  context.edx  | </p>\n<p>-----------------</p>\n<p>|  context.ecx  | </p>\n<p>-----------------</p>\n<p>|  context.ebx  | </p>\n<p>-----------------</p>\n<p>|  context.esp  | </p>\n<p>-----------------</p>\n<p>|  context.eip   |   低地址</p>\n<p>-----------------</p>", "anon": "no", "subject": "", "uid": "i0f9pvv0uxm6ko", "created": "2016-03-28T05:08:55Z"}, {"content": "<p>先从调用switch_to处说起吧&#xff0c;</p>\n<pre>switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));</pre>\n<p>代码是这样的&#xff0c;prev是上一个进程的上下文&#xff0c;next是本进程的上下文。</p>\n<p></p>\n<p>由于这个函数是汇编写的&#xff0c;这里就涉及到x86下C语言对栈帧的使用&#xff0c;这里只介绍相关的少许知识&#xff0c;以下是C调用完switch_to以后的栈帧情况&#xff1a;</p>\n<p>----------------------------</p>\n<p>|  arg1: next-&gt;context    |</p>\n<p>----------------------------</p>\n<p>|  arg0: prev-&gt;context    |</p>\n<p>----------------------------</p>\n<p>|  return address            |    ---&gt; esp</p>\n<p>----------------------------</p>\n<p></p>\n<p>现在我们来看位于switch.S中的代码&#xff0c;第一部分是保存现场</p>\n<pre>    movl 4(%esp), %eax          # esp&#43;4的位置即为prev-&gt;context&#xff0c;这句话把这个指针放入了eax中\n    popl 0(%eax)                # 由于esp所在的位置是返回地址&#xff0c;其实在进程切换的角度来看&#xff0c;这个地址就是原进程恢复后该执行的地址&#xff0c;所以把它保存到prev-&gt;context中eip对应的位置。\n    movl %esp, 4(%eax)\t\t# 保存esp&#xff0c;之后的类似&#xff0c;这里的保存顺序很重要&#xff0c;必须按照context的结构来&#xff0c;具体见附录的context结构体描述&#xff0c;这里默认这个顺序是合理的就行了\n    movl %ebx, 8(%eax)\t\t# 保存ebx&#xff0c;以下略\n    movl %ecx, 12(%eax)\n    movl %edx, 16(%eax)\n    movl %esi, 20(%eax)\n    movl %edi, 24(%eax)\n    movl %ebp, 28(%eax)</pre>\n<p></p>\n<p>现在&#xff0c;由于popl了返回地址&#xff0c;栈帧是这样的&#xff1a;</p>\n<p>----------------------------</p>\n<p>|  arg1: next-&gt;context    |</p>\n<p>----------------------------</p>\n<p>|  arg0: prev-&gt;context    |   ---&gt; esp</p>\n<p>----------------------------</p>\n<p></p>\n<p>所以恢复现场是这样的&#xff0c;依旧注意一下恢复顺序&#xff1a;</p>\n<pre>    movl 4(%esp), %eax          # 现在的esp&#43;4对应于next-&gt;context&#xff0c;把这个指针放入eax中\n    # 按context结构来恢复现场                         \t   \n    movl 28(%eax), %ebp\t\t\n    movl 24(%eax), %edi\n    movl 20(%eax), %esi\n    movl 16(%eax), %edx\n    movl 12(%eax), %ecx\n    movl 8(%eax), %ebx\n    movl 4(%eax), %esp</pre>\n<p></p>\n<p>这样以来现场保存和恢复工作就做好了&#xff0c;最后剩跳转到新的进程&#xff1a;</p>\n<pre>    pushl 0(%eax)               # 把next-&gt;context中的eip压入栈\n    ret</pre>\n<p></p>\n<p>注意到我们先弹出了一个原进程的返回地址&#xff0c;现在又压入了一个新进程的返回地址&#xff0c;switch_to没有破坏栈帧结构。</p>\n<p></p>\n<p></p>\n<p>附&#xff1a;</p>\n<p>context类型和在内存中的存放</p>\n<pre>struct context {\n    uint32_t eip;\n    uint32_t esp;\n    uint32_t ebx;\n    uint32_t ecx;\n    uint32_t edx;\n    uint32_t esi;\n    uint32_t edi;\n    uint32_t ebp;\n};</pre>\n<p></p>", "anon": "no", "subject": "", "uid": "i0f9pvv0uxm6ko", "created": "2016-03-28T04:24:36Z"}]}, {"folders": [], "updated": "2016-04-01T13:21:55Z", "no_upvotes": 0, "uid": "ikx8y1dzPrM", "created": "2016-04-01T13:21:55Z", "type": "followup", "no_answer": 1, "id": "imhqor8uqa93vk", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": null, "children": [], "subject": "<p>&#64;作者  问一下switch_to中对from保存的上下文是schedule()中switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));这一行代码的上下文么&#xff1f;</p>"}], "request_instructor_me": false, "nr": 743, "bucket_order": 2, "config": {}, "status": "active", "tags": ["lecture11", "student", "课堂问答"], "num_favorites": 0, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2016-03-28T01:35:30Z", "is_tag_good": false, "type": "question", "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1459524656299, "tag_good": [], "tag_good_arr": [], "history": [{"content": "<p>/lab4/kern/process/switch.S文件中&#xff0c;</p>\n<p></p>\n<p>如何理解这段代码&#xff1f;</p>\n<p>代码中两个部分即保存现场和恢复现场是怎样对应链接的&#xff1f;</p>\n<p>C代码是如何与汇编代码对接的&#xff1f;</p>", "anon": "no", "subject": "课堂提问 进程切换代码", "uid": "i0gl5kctugw3xi", "created": "2016-03-28T06:59:35Z"}, {"content": "<p>/lab4/kern/process/switch.S文件中&#xff0c;</p>\n<p></p>\n<p>如何理解这段代码&#xff1f;</p>\n<p>代码中两个部分即保存现场和恢复现场是怎样对应链接的&#xff1f;</p>", "anon": "no", "subject": "课堂提问 进程切换代码", "uid": "i1jd60b7orl10p", "created": "2016-03-28T01:35:30Z"}]}, "error": null}