{"error": null, "result": {"nr": 105, "upvote_ids": [], "change_log": [{"type": "create", "when": "2015-03-15T01:08:28Z", "uid": "i6urm1j1ynv6sm", "data": "i79quai51gt5tw", "anon": "no"}, {"type": "update", "when": "2015-03-15T01:09:25Z", "uid": "i6urm1j1ynv6sm", "data": "i79qvhuscjb6cu", "anon": "no"}, {"uid": "hdjonbiyfs62ie", "to": "i79quai2vw85tv", "when": "2015-03-15T01:21:17Z", "anon": "no", "data": "i79rarmx6nx6q7", "type": "i_answer"}, {"type": "followup", "to": "i79quai2vw85tv", "when": "2015-03-15T01:34:40Z", "uid": "i6urm1j1ynv6sm", "anon": "no"}, {"type": "feedback", "to": "i79quai2vw85tv", "when": "2015-03-15T01:44:11Z", "uid": "hdjonbiyfs62ie", "anon": "no"}, {"type": "feedback", "to": "i79quai2vw85tv", "when": "2015-03-15T01:47:40Z", "uid": "hdjonbiyfs62ie", "anon": "no"}, {"type": "feedback", "to": "i79quai2vw85tv", "when": "2015-03-15T02:12:13Z", "uid": "i6urm1j1ynv6sm", "anon": "no"}, {"type": "feedback", "to": "i79quai2vw85tv", "when": "2015-03-15T02:15:23Z", "uid": "i6urm1j1ynv6sm", "anon": "no"}, {"type": "feedback", "to": "i79quai2vw85tv", "when": "2015-03-17T07:53:45Z", "uid": "hdjonbiyfs62ie", "anon": "no"}], "q_edits": [], "i_edits": [], "unique_views": 116, "bookmarked": 3, "config": {}, "history": [{"subject": "计算机加电后&#xff0c;CPU执行的第一条指令在0xFFFFFFF0还是0x7c00?", "content": "<p>1、听了课件&#xff0c;感觉应该是在0x7c00&#xff1b;但是gitbooks中3.1 BIOS启动过程有这样的话&#xff1a;“以Intel 80386为例&#xff0c;计算机加电后&#xff0c;CPU从物理地址0xFFFFFFF0&#xff08;由初始化的CS&#xff1a;EIP确定&#xff0c;此时CS和IP的值分别是0xF000和0xFFF0)&#xff09;开始执行。在0xFFFFFFF0这里只是存放了一条跳转指令&#xff0c;通过跳转指令跳到BIOS例行程序起始点。”  所以第一条指令应该是在0xFFFFFFF0吧&#xff1f;</p>\n<p></p>\n<p>2、还有问题&#xff1a;如果刚启动的时候&#xff0c;默认处于实模式&#xff1b;那么应该没法寻址到0xFFFFFFF0去吧&#xff1f;</p>\n<p>我尝试了一下&#xff0c;虽然info break&#xff0c;得到的结果是&#xff1a;</p>\n<p>   1 breakpoint keep y 0xfffffff0 </p>\n<p>但执行contine后&#xff0c;会得到提示&#xff1a;</p>\n<p>   Program received signal SIGTRAP, Trace/breakpoint trap.<br />   0x0000fff0 in ?? ()</p>\n<p>也就是它的pc是0xfff0&#xff1b;并且此处的指令也并不是一条跳转指令啊。</p>\n<p></p>\n<p>3、另外&#xff0c;如果cs是0xF000&#xff0c;IP是0xFFF0&#xff0c;为什么得到的地址是0xFFFFFFF0&#xff1f;怎么算出来的&#xff1f;</p>\n<p><br />===附上我调试的命令<br />终端1&#xff1a;</p>\n<p>../lab1$ qemu -S -s -hda bin/ucore.img ## 启动qemu&#xff0c;让qemu进入等待gdb调试器的接入并且不能让其中的CPU执行。</p>\n<p>终端2&#xff1a;<br />1&#xff09;../lab1$ gdb bin/kernel<br />2&#xff09;(gdb) target remote:1234<br />3&#xff09;(gdb) set architecture i8086<br />4&#xff09;(gdb) b *0xFFFFFFF0<br />5&#xff09;(gdb) continue<br />6&#xff09;(gdb) x /10i $pc</p>\n<p>===</p>\n<p>应该没有问题吧&#xff1f;</p>\n<p></p>\n<p></p>\n<p></p>", "created": "2015-03-15T01:09:25Z", "uid": "i6urm1j1ynv6sm", "anon": "no"}, {"subject": "计算机加电后&#xff0c;CPU执行的第一条指令在0xFFFFFFF0还是0x7c00?", "content": "<p>1、听了课件&#xff0c;感觉应该是在0x7c00&#xff1b;但是gitbooks中3.1 BIOS启动过程有这样的话&#xff1a;“以Intel 80386为例&#xff0c;计算机加电后&#xff0c;CPU从物理地址0xFFFFFFF0&#xff08;由初始化的CS&#xff1a;EIP确定&#xff0c;此时CS和IP的值分别是0xF000和0xFFF0)&#xff09;开始执行。在0xFFFFFFF0这里只是存放了一条跳转指令&#xff0c;通过跳转指令跳到BIOS例行程序起始点。”  所以第一条指令应该是在0xFFFFFFF0吧&#xff1f;</p>\n<p></p>\n<p>2、还有问题&#xff1a;如果刚启动的时候&#xff0c;默认处于实模式&#xff1b;那么应该没法寻址到0xFFFFFFF0去呀。我尝试了一下&#xff0c;虽然info break&#xff0c;得到的结果是&#xff1a;</p>\n<p>   1 breakpoint keep y 0xfffffff0 </p>\n<p>但执行contine后&#xff0c;会得到提示&#xff1a;</p>\n<p>   Program received signal SIGTRAP, Trace/breakpoint trap.<br />   0x0000fff0 in ?? ()</p>\n<p>也就是它的pc是0xfff0&#xff1b;并且此处的指令也并不是一条跳转指令啊。</p>\n<p></p>\n<p>3、另外&#xff0c;如果cs是0xF000&#xff0c;IP是0xFFF0&#xff0c;为什么得到的地址是0xFFFFFFF0&#xff1f;怎么算出来的&#xff1f;</p>\n<p><br />===附上我调试的命令<br />终端1&#xff1a;</p>\n<p>../lab1$ qemu -S -s -hda bin/ucore.img ## 启动qemu&#xff0c;让qemu进入等待gdb调试器的接入并且不能让其中的CPU执行。</p>\n<p>终端2&#xff1a;<br />1&#xff09;../lab1$ gdb bin/kernel<br />2&#xff09;(gdb) target remote:1234<br />3&#xff09;(gdb) set architecture i8086<br />4&#xff09;(gdb) b *0xFFFFFFF0<br />5&#xff09;(gdb) continue<br />6&#xff09;(gdb) x /10i $pc</p>\n<p>===</p>\n<p>应该没有问题吧&#xff1f;</p>\n<p></p>\n<p></p>\n<p></p>", "created": "2015-03-15T01:08:28Z", "uid": "i6urm1j1ynv6sm", "anon": "no"}], "data": {"embed_links": []}, "request_instructor_me": false, "folders": ["lab1"], "type": "question", "tag_good": [], "no_answer": 0, "created": "2015-03-15T01:08:28Z", "t": 1433500081376, "id": "i79quai2vw85tv", "status": "active", "tag_good_arr": [], "default_anonymity": "no", "my_favorite": false, "bucket_order": 2, "is_bookmarked": false, "is_tag_good": false, "bucket_name": "Today", "no_answer_followup": 0, "children": [{"folders": [], "bucket_order": 2, "config": {}, "history": [{"subject": "", "content": "<p>CPU加电后的第一条指令位置的讨论需要明确一下上下文环境。这里有32位和16位两种实模式。在视频中的说的8086的16位实模式&#xff0c;它的地址就是0xFFFF0。在32位实模式时&#xff0c;这时的寄存器都是32位的了&#xff0c;地址就是0xFFFFFFF0了&#xff1b;为了能访问0xFFFF0&#xff0c;就有了A20的控制&#xff0c;强制只有20位&#xff08;1MB&#xff09;的地址空间。</p>\n<p></p>\n<p>你在标题上说的0x7c00是什么意思&#xff1f;</p>", "created": "2015-03-15T01:21:17Z", "uid": "hdjonbiyfs62ie", "anon": "no"}], "data": {"embed_links": []}, "bucket_name": "Today", "is_tag_endorse": false, "children": [], "tag_endorse": [], "tag_endorse_arr": [], "created": "2015-03-15T01:21:17Z", "id": "i79rarix4tr6q5", "type": "i_answer"}, {"no_upvotes": 0, "uid": "i6urm1j1ynv6sm", "bucket_name": "This week", "bucket_order": 4, "updated": "2015-03-15T01:34:40Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>我好像忽视了BIOS的启动过程。0x7c00是bootloader的入口位置吧&#xff1f;</p>\n<p>所以是先在0xFFFFFFF0&#xff0c;跳转到BIOS入口&#xff0c;再加载bootloader&#xff0c;再跳转到bootloader入口&#xff0c;最后到kernel&#xff1f;</p>\n<p>竟然还有32位的实模式&#xff1f;那启动的时候到底是在16位还是32位下呢&#xff1f;</p>\n<p>如果应该是32位的实模式&#xff0c;那我是不是不应该在调试前就设置architecture&#xff0c;就是set architecture i8086&#xff1f;set以后&#xff0c;应该就是16位实模式了吧&#xff1f;</p>\n<p></p>\n<p>gitbooks上说“cs是0xF000&#xff0c;IP是0xFFF0”&#xff0c;不管怎么算&#xff0c;也不会得到0xFFFFFFF0啊&#xff1f;前4个都是F是为什么&#xff1f;</p>", "children": [{"uid": "hdjonbiyfs62ie", "bucket_name": "This week", "bucket_order": 4, "updated": "2015-03-15T01:44:11Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>0x7c00是bootloader的入口位置。</p>\n<p></p>\n<p>在32位时&#xff0c;寄存器是32位的&#xff0c;这时CS就是0xFFFF F000了。</p>\n<p></p>\n<p>余下的问题&#xff0c;也许可以从网上找到一个完整的回答。你可以找一下&#xff0c;然后列到后面。我这里略过了。</p>", "children": [], "type": "feedback", "created": "2015-03-15T01:44:11Z", "id": "i79s47kto6z6ms"}, {"uid": "hdjonbiyfs62ie", "bucket_name": "This week", "bucket_order": 4, "updated": "2015-03-15T01:47:40Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p><a href=\"https://www.piazza.com/class/i5j09fnsl7k5x0?cid=91\">https://piazza.com/class/i5j09fnsl7k5x0?cid=91</a></p>\n<p>这是前几天其他同学的提问和回答。</p>", "children": [], "type": "feedback", "created": "2015-03-15T01:47:40Z", "id": "i79s8oqdhbof2"}, {"uid": "i6urm1j1ynv6sm", "bucket_name": "This week", "bucket_order": 4, "updated": "2015-03-15T02:12:13Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>感觉我的问题和他的问题并不是很相似&#xff0c;依旧不是很明白。</p>\n<p>为什么IP不进行符号扩展&#xff1f;</p>\n<p>以及为什么在0xffff fff0处设置断点&#xff0c;并没有看到有跳转指令&#xff1f;</p>\n<p>设置architecture的问题&#xff0c;我还是自己查吧....</p>", "children": [], "type": "feedback", "created": "2015-03-15T02:12:13Z", "id": "i79t49iiturv8"}, {"uid": "i6urm1j1ynv6sm", "bucket_name": "This week", "bucket_order": 4, "updated": "2015-03-15T02:15:23Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>疏忽了&#xff0c;我先看看</p>", "children": [], "type": "feedback", "created": "2015-03-15T02:15:23Z", "id": "i79t8c6tn8i2of"}, {"uid": "hdjonbiyfs62ie", "bucket_name": "Today", "bucket_order": 2, "updated": "2015-03-17T07:53:45Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>下面链接又是一个对CPU加电后的第一条指令的分析。</p>\n<p></p>\n<p>http://www.doc88.com/p-577882999790.html<br />cpu执行的第一条指令的情形</p>", "children": [], "type": "feedback", "created": "2015-03-17T07:53:45Z", "id": "i7d076s2w3a2y4"}], "type": "followup", "no_answer": 0, "created": "2015-03-15T01:34:40Z", "id": "i79rryq79l842u"}], "request_instructor": 0, "tags": ["lab1", "student"], "s_edits": [], "num_favorites": 0}, "aid": "iajgxpsw7046ju"}